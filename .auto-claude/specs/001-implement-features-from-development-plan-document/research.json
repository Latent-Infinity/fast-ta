{
  "integrations_researched": [
    {
      "name": "Criterion.rs",
      "type": "library",
      "verified_package": {
        "name": "criterion",
        "install_command": "Add to Cargo.toml: criterion = \"0.5.1\"",
        "version": "0.5.1 (latest stable)",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "use criterion::{criterion_group, criterion_main, Criterion};",
          "use std::hint::black_box;",
          "use criterion::{BenchmarkGroup, BenchmarkId, Throughput};"
        ],
        "initialization": "fn criterion_benchmark(c: &mut Criterion) {\n    c.bench_function(\"name\", |b| b.iter(|| function_to_bench()));\n}\n\ncriterion_group!(benches, criterion_benchmark);\ncriterion_main!(benches);",
        "key_functions": [
          "Criterion::benchmark_group() - Create benchmark groups",
          "BenchmarkGroup::bench_function() - Define benchmarks",
          "Bencher::iter() - Run iterations",
          "black_box() - Prevent compiler optimizations",
          "BenchmarkGroup::throughput() - Measure throughput",
          "BenchmarkGroup::sample_size() - Configure sample count",
          "BenchmarkGroup::measurement_time() - Set measurement duration"
        ],
        "verified_against": "Context7 MCP: /bheisler/criterion.rs"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [
          "Criterion.toml (optional for customization)",
          "Cargo.toml [[bench]] sections"
        ],
        "dependencies": [],
        "cargo_toml_setup": {
          "dev_dependencies": "criterion = \"0.5.1\"",
          "bench_section": "[[bench]]\nname = \"benchmark_name\"\nharness = false",
          "note": "harness = false is REQUIRED to disable default benchmark harness"
        }
      },
      "key_features": [
        "Statistical analysis with confidence intervals",
        "Automatic outlier detection",
        "HTML report generation with plots",
        "JSON output for CI systems",
        "Throughput measurement (Bytes/Elements per second)",
        "Parameterized benchmarks",
        "Warm-up and measurement time configuration",
        "Multiple output formats (criterion, verbose, bencher, quiet)"
      ],
      "infrastructure": {
        "requires_docker": false,
        "plotting_backend": "gnuplot or plotters (auto-detect)",
        "output_directory": "./target/criterion"
      },
      "gotchas": [
        "Must set harness = false in [[bench]] section of Cargo.toml",
        "black_box() is essential to prevent compiler from optimizing away benchmarked code",
        "Default features include rayon - disable for WASI with default-features = false",
        "Benchmark functions must take &mut Criterion parameter",
        "For long benchmarks, use SamplingMode::Flat to reduce overhead",
        "Statistical significance level default is 0.05, can be adjusted with .significance_level()"
      ],
      "research_sources": [
        "Context7 MCP: /bheisler/criterion.rs",
        "GitHub: https://github.com/bheisler/criterion.rs"
      ]
    },
    {
      "name": "petgraph",
      "type": "library",
      "verified_package": {
        "name": "petgraph",
        "install_command": "Add to Cargo.toml: petgraph = \"0.6\"",
        "version": "0.6.x (stable)",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "use petgraph::prelude::*;",
          "use petgraph::graph::{Graph, DiGraph, UnGraph};",
          "use petgraph::algo::toposort;",
          "use petgraph::Direction;",
          "use petgraph::visit::{IntoNeighborsDirected, NodeIndexable};"
        ],
        "initialization": "// Create directed graph\nlet mut graph = DiGraph::<NodeData, EdgeData>::new();\n\n// Create from edges\nlet g = Graph::<(), ()>::from_edges(&[(0, 1), (1, 2)]);",
        "key_functions": [
          "Graph::new() / DiGraph::new() - Create graphs",
          "add_node(weight) - Add node with data",
          "add_edge(from, to, weight) - Add edge",
          "neighbors(node) - Get neighbors iterator",
          "toposort(graph, space) - Topological sort (returns Result)",
          "dag_to_toposorted_adjacency_list() - DAG conversion",
          "is_cyclic_directed() - Cycle detection",
          "from_edges(edges) - Create graph from edge list"
        ],
        "verified_against": "Context7 MCP: /websites/rs-petgraph"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": [
          "indexmap (for stable node/edge ordering)",
          "fixedbitset (for visit maps)"
        ]
      },
      "key_features": [
        "Multiple graph types: Graph, StableGraph, GraphMap",
        "Directed and undirected edges",
        "Generic node and edge weights",
        "Topological sorting with cycle detection",
        "Transitive reduction and closure algorithms",
        "Graphviz export",
        "Various graph algorithms (DFS, BFS, shortest path, etc.)",
        "Compact node indexing"
      ],
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "toposort() returns Result<Vec<NodeId>, Cycle> - MUST handle cycle errors",
        "Graph removes nodes by swapping with last node - use StableGraph if indices must be stable",
        "Node indices can be invalidated after node removal in Graph (not StableGraph)",
        "For DAG operations, nodes must be processed in topological order",
        "Cycle detection includes self-loops",
        "neighbors() returns outgoing edges for directed graphs, all edges for undirected"
      ],
      "research_sources": [
        "Context7 MCP: /websites/rs-petgraph",
        "docs.rs documentation"
      ]
    },
    {
      "name": "num-traits",
      "type": "library",
      "verified_package": {
        "name": "num-traits",
        "install_command": "Add to Cargo.toml: num-traits = \"0.2\"",
        "version": "0.2.x (stable)",
        "verified": true
      },
      "api_patterns": {
        "imports": [
          "use num_traits::{Float, Num, Zero, One};",
          "use num_traits::cast::{NumCast, ToPrimitive, FromPrimitive};",
          "use num_traits::float::FloatCore;"
        ],
        "initialization": "// Generic function example\nfn sma<T: Float>(data: &[T], period: usize) -> Vec<T> {\n    // T can be f32 or f64\n}",
        "key_functions": [
          "Float trait - for f32/f64 with NaN, infinity support",
          "Num trait - basic numeric operations",
          "Zero::zero() - Get zero value",
          "One::one() - Get one value",
          "NumCast::from() - Safe numeric casting",
          "Float::is_nan() - NaN checking",
          "Float::abs() - Absolute value"
        ],
        "verified_against": "Standard Rust ecosystem crate (part of rust-num organization)"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": [],
        "features": [
          "std (default) - Standard library support",
          "libm - Pure Rust math implementation for no_std"
        ]
      },
      "key_features": [
        "Generic numeric traits for abstraction over number types",
        "Zero and One traits for identity elements",
        "Float trait for floating-point operations",
        "Bounded, Saturating, CheckedOps for safe arithmetic",
        "NumCast for type conversions",
        "no_std support with libm feature"
      ],
      "infrastructure": {
        "requires_docker": false
      },
      "gotchas": [
        "Float trait requires handling NaN and infinity explicitly",
        "Some operations may panic on overflow unless using Checked* traits",
        "NumCast::from() returns Option - must handle None for invalid conversions",
        "In no_std environments, enable libm feature for math functions"
      ],
      "research_sources": [
        "Standard Rust ecosystem documentation",
        "Part of rust-num organization (well-established)"
      ]
    },
    {
      "name": "TA-Lib (Technical Analysis Library)",
      "type": "external_comparison_baseline",
      "verified_package": {
        "name": "TA-Lib (C library) / ta-lib (Python wrapper)",
        "install_command": "C library: brew install ta-lib (macOS) or compile from source\nPython: pip install TA-Lib",
        "version": "0.4.0+ (C), 0.6.4 (latest source)",
        "verified": false,
        "note": "No official Rust bindings found - requires decision on comparison approach"
      },
      "api_patterns": {
        "imports": [
          "Python: import talib",
          "Python: from talib import SMA, EMA, RSI, MACD"
        ],
        "initialization": "Python: result = talib.SMA(data, timeperiod=20)",
        "key_functions": [
          "SMA(data, timeperiod) - Simple Moving Average",
          "EMA(data, timeperiod) - Exponential Moving Average",
          "RSI(data, timeperiod) - Relative Strength Index",
          "MACD(data, fast, slow, signal) - MACD indicator",
          "BBANDS(data, timeperiod, nbdevup, nbdevdn) - Bollinger Bands",
          "ATR(high, low, close, timeperiod) - Average True Range"
        ],
        "verified_against": "Context7 MCP: /ta-lib/ta-lib-python (Python wrapper)"
      },
      "configuration": {
        "env_vars": [
          "TA_LIBRARY_PATH - Path to TA-Lib library (if custom install)",
          "TA_INCLUDE_PATH - Path to TA-Lib headers"
        ],
        "config_files": [],
        "dependencies": [
          "C library: Must compile from source or use package manager",
          "Python: Requires NumPy, Cython (for building from source)"
        ]
      },
      "infrastructure": {
        "requires_docker": false,
        "requires_c_library": true,
        "platform_notes": "C library must be compiled and installed before Python wrapper"
      },
      "comparison_approaches": [
        {
          "option": "Python subprocess calling TA-Lib",
          "pros": "Accurate real-world comparison, measures actual TA-Lib performance",
          "cons": "Subprocess overhead, complex setup, Python dependency",
          "complexity": "high"
        },
        {
          "option": "Pre-computed golden files",
          "pros": "Fast, no runtime dependency, simple CI integration",
          "cons": "Doesn't measure TA-Lib runtime, only validates correctness",
          "complexity": "low",
          "recommended": true
        },
        {
          "option": "FFI bindings to TA-Lib C library",
          "pros": "Direct performance comparison, accurate benchmarking",
          "cons": "Complex build setup, platform-specific issues, linking challenges",
          "complexity": "very high"
        },
        {
          "option": "Use alternative Rust TA library for comparison",
          "pros": "Pure Rust, easier integration, fair comparison",
          "cons": "May not match TA-Lib exactly, different implementation choices",
          "complexity": "medium",
          "alternatives": ["ta crate", "rust_ta_lib (if exists)"]
        }
      ],
      "gotchas": [
        "TA-Lib C library must be installed BEFORE Python wrapper",
        "macOS: Use homebrew (brew install ta-lib) for easiest setup",
        "Linux: Must compile from source with ./configure && make && sudo make install",
        "Python wrapper requires NumPy and Cython to build",
        "No official Rust bindings exist - comparison requires cross-language approach",
        "Different platforms may have different installation requirements",
        "Header file location varies by platform - may need TA_INCLUDE_PATH",
        "For Rust project: Decision needed on comparison strategy (Task 0.6 in plan)"
      ],
      "research_sources": [
        "Context7 MCP: /ta-lib/ta-lib-python",
        "Context7 MCP: /ta-lib/ta-lib.github.io",
        "Official: https://ta-lib.org"
      ]
    },
    {
      "name": "perf (Linux Performance Counters)",
      "type": "system_tool",
      "verified_package": {
        "name": "perf / linux-tools-common",
        "install_command": "apt-get install linux-tools-common linux-tools-generic (Ubuntu/Debian)\nyum install perf (RedHat/CentOS)",
        "version": "Kernel-specific version",
        "verified": true
      },
      "api_patterns": {
        "imports": [],
        "initialization": "Command-line tool, not a library",
        "key_functions": [
          "perf stat - Run command and gather performance statistics",
          "perf record - Record performance data",
          "perf report - Analyze recorded data",
          "perf stat -e cache-misses - Measure cache misses",
          "perf stat -e branch-misses - Measure branch mispredictions"
        ],
        "verified_against": "Standard Linux performance profiling tool"
      },
      "configuration": {
        "env_vars": [],
        "config_files": [],
        "dependencies": [],
        "usage_examples": [
          "perf stat -e cycles,instructions,cache-references,cache-misses ./benchmark",
          "perf stat -e branch-instructions,branch-misses cargo bench",
          "perf record -e cpu-clock -F 99 -g ./benchmark",
          "perf stat -r 10 ./benchmark  # Run 10 times"
        ]
      },
      "key_features": [
        "Hardware performance counter access",
        "Cache miss measurement",
        "Branch misprediction tracking",
        "CPU cycle counting",
        "IPC (instructions per cycle) calculation",
        "Sampling profiler",
        "Call graph profiling"
      ],
      "infrastructure": {
        "requires_docker": false,
        "platform_specific": "Linux only - not available on macOS or Windows",
        "kernel_requirement": "Linux kernel with performance counters enabled",
        "permissions": "May require root/sudo or perf_event_paranoid kernel parameter adjustment"
      },
      "gotchas": [
        "Linux-only tool - alternative needed for macOS/Windows benchmarks",
        "May require sudo or kernel parameter changes: sysctl kernel.perf_event_paranoid=1",
        "Performance counters may not be available in virtualized environments",
        "Counter names vary by CPU architecture (Intel vs AMD)",
        "Docker containers may not have access to perf counters without --privileged",
        "Results depend on CPU model and capabilities",
        "Some events may not be available on all processors",
        "Use 'perf list' to see available events on current system"
      ],
      "alternatives": {
        "macOS": "Instruments.app or DTrace",
        "Windows": "Windows Performance Analyzer",
        "Cross-platform": "cargo-criterion (some hardware counter support), likwid-bench"
      },
      "research_sources": [
        "Linux kernel documentation",
        "perf wiki: https://perf.wiki.kernel.org/"
      ]
    }
  ],
  "unverified_claims": [
    {
      "claim": "TA-Lib has Rust bindings for direct FFI comparison",
      "reason": "No official Rust TA-Lib bindings found in Context7 or standard Rust ecosystem. Only Python wrapper found.",
      "risk_level": "medium",
      "mitigation": "Task 0.6 in development plan addresses this - requires human decision on comparison strategy"
    },
    {
      "claim": "perf counters will be available in all benchmark environments",
      "reason": "perf is Linux-only and may not work in Docker/CI without special permissions",
      "risk_level": "low",
      "mitigation": "Development plan says 'if available' - benchmarks should work without perf, just with less detailed metrics"
    }
  ],
  "recommendations": [
    {
      "category": "TA-Lib Comparison",
      "recommendation": "Use pre-computed golden files approach for E01 and E07 experiments",
      "rationale": "Simplest to implement, validates correctness without complex FFI or subprocess overhead. Runtime comparison can use native Rust baseline instead.",
      "priority": "high"
    },
    {
      "category": "Criterion Configuration",
      "recommendation": "Use consistent configuration across all benchmarks with explicit sample sizes",
      "rationale": "Development plan emphasizes statistical rigor - standardize warm-up (3s), measurement (5s), and sample size (100) in common/mod.rs",
      "priority": "high"
    },
    {
      "category": "perf Integration",
      "recommendation": "Make perf metrics optional and document how to enable them",
      "rationale": "perf is platform-specific and may not be available in all CI environments. Benchmarks should run without it.",
      "priority": "medium"
    },
    {
      "category": "num-traits Usage",
      "recommendation": "Use Float trait bound (not f64 directly) for all indicator implementations",
      "rationale": "Enables generic implementations that work with both f32 and f64, improving reusability and testing",
      "priority": "high"
    },
    {
      "category": "petgraph DAG",
      "recommendation": "Always use toposort() with proper error handling for cycle detection",
      "rationale": "Plan registry (Task 3.3) must detect cyclic dependencies in indicator plans. toposort returns Result<Vec, Cycle> that must be handled.",
      "priority": "high"
    },
    {
      "category": "Benchmark Output",
      "recommendation": "Configure Criterion to output both JSON (for CI) and HTML (for human review)",
      "rationale": "Development plan specifies outputs should be machine-readable (results.json) and human-readable (REPORT.md)",
      "priority": "medium"
    }
  ],
  "context7_libraries_used": [
    "/bheisler/criterion.rs",
    "/websites/rs-petgraph",
    "/ta-lib/ta-lib-python",
    "/ta-lib/ta-lib.github.io"
  ],
  "missing_rust_equivalents": [
    {
      "name": "TA-Lib for Rust",
      "purpose": "Direct comparison baseline for E01 and E07 benchmarks",
      "workaround": "Use Python TA-Lib via subprocess, pre-computed golden files, or alternative Rust TA library"
    }
  ],
  "additional_dependencies_identified": [
    {
      "name": "rand or fastrand",
      "purpose": "Random number generation for synthetic data generators (Task 0.4)",
      "verified": false,
      "recommendation": "Use rand crate with ChaCha or Pcg64 for reproducible seeded RNG"
    },
    {
      "name": "serde and serde_json",
      "purpose": "Serializing benchmark results to JSON format (mentioned in Task 2.1 outputs)",
      "verified": false,
      "recommendation": "Standard serialization crates for benchmark output"
    }
  ],
  "created_at": "2024-12-20T12:00:00Z",
  "research_phase_status": "complete",
  "next_phase_blockers": [
    {
      "task": "Task 0.6 - Baseline Comparison Strategy",
      "blocker": "Human decision required on TA-Lib comparison approach",
      "options": ["Python subprocess", "Golden files", "FFI bindings", "Alternative Rust library"],
      "recommended": "Golden files for simplicity"
    }
  ]
}
